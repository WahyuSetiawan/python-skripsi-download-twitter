
    def main(self):
        ''' This is a script that continuously searches for tweets
            that were created over a given number of days. The search
            dates and search phrase can be changed below. '''



        ''' search variables: '''
        search_phrases = ['pantai', 'pantaiparis', 
                         'gunungsemeru', 'pantaiwdiombo',
                         'parangkusumo', 'prambanan',
                         'monas','karimunjawa','bandung','keratonsurakarta']
        time_limit = 20                          # runtime limit in hours
        max_tweets = 100                           # number of tweets per search (will be
                                                   # iterated over) - maximum is 100
        min_days_old, max_days_old = 0,10          # search limits e.g., from 7 to 8
                                                   # gives current weekday from last week,
                                                   # min_days_old=0 will search from right now
        JBD = '-6.2891084,106.7560364,1000km'       # this geocode includes nearly all American
                                                  # states (and a large portion of Canada)
    

        # loop over search items,
        # creating a new file for each
        for search_phrase in search_phrases:

            print('Search phrase =', search_phrase)

            ''' other variables '''
            name = search_phrase.split()[0]
            json_file_root = name + '/'  + name
            os.makedirs(os.path.dirname(json_file_root), exist_ok=True)
            read_IDs = False
        
            # open a file in which to store the tweets
            if max_days_old - min_days_old == 1:
                d = dt.datetime.now() - dt.timedelta(days=min_days_old)
                day = '{0}-{1:0>2}-{2:0>2}'.format(d.year, d.month, d.day)
            else:
                d1 = dt.datetime.now() - dt.timedelta(days=max_days_old-1)
                d2 = dt.datetime.now() - dt.timedelta(days=min_days_old)
                day = '{0}-{1:0>2}-{2:0>2}_to_{3}-{4:0>2}-{5:0>2}'.format(
                      d1.year, d1.month, d1.day, d2.year, d2.month, d2.day)
            json_file = json_file_root + '_' + day + '.json'
            if os.path.isfile(json_file):
                print('Appending tweets to file named: ',json_file)
                read_IDs = True
        
            # authorize and load the twitter API
            api = load_api()
        
            # set the 'starting point' ID for tweet collection
            if read_IDs:
                # open the json file and get the latest tweet ID
                with open(json_file, 'r') as f:
                    lines = f.readlines()
                    max_id = json.loads(lines[-1])['id']
                    print('Searching from the bottom ID in file')
            else:
                # get the ID of a tweet that is min_days_old
                if min_days_old == 0:
                    max_id = -1
                else:
                    max_id = get_tweet_id(api, days_ago=(min_days_old-1))
            # set the smallest ID to search for
            since_id = get_tweet_id(api, days_ago=(max_days_old-1))
            print('max id (starting point) =', max_id)
            print('since id (ending point) =', since_id)
        


            ''' tweet gathering loop  '''
            start = dt.datetime.now()
            end = start + dt.timedelta(hours=time_limit)
            count, exitcount = 0, 0
            while dt.datetime.now() < end:
                count += 1
                print('count =',count)
                # collect tweets and update max_id
                tweets, max_id = tweet_search(api, search_phrase, max_tweets,
                                              max_id=max_id, since_id=since_id
                                              ,geocode=JBD)
                # write tweets to file in JSON format
                if tweets:
                    write_tweets(tweets, json_file)
                    exitcount = 0
                else:
                    exitcount += 1
                    if exitcount == 3:
                        if search_phrase == search_phrases[-1]:
                            sys.exit('Maximum number of empty tweet strings reached - exiting')
                        else:
                            print('Maximum number of empty tweet strings reached - breaking')
                            break


    if __name__ == "__main__":
        main()